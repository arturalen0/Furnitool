<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Couch Configurator</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: sans-serif;
      }

      canvas {
        display: block;
        width: 100vw !important;
        height: 100vh !important;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 1;
      }
      #ui-container {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(255, 255, 255, 0.9);
        padding: 15px;
        border-radius: 10px;
        z-index: 10;
        backdrop-filter: blur(5px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .control-group {
        margin-bottom: 10px;
      }
      label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      select {
        padding: 5px;
        border-radius: 5px;
        border: 1px solid #ccc;
      }
    </style>
  </head>
  <body>
    <div id="ui-container">
      <div class="control-group">
        <label for="model-select">Couch Model:</label>
        <select id="model-select"></select>
      </div>
      <div class="control-group">
        <label for="fabric-select">Fabric Material:</label>
        <select id="fabric-select"></select>
      </div>
      <div class="control-group">
        <label for="stitch-select">Stitch Color:</label>
        <select id="stitch-select"></select>
      </div>
      <div class="control-group">
        <label for="legs-select">Legs Material:</label>
        <select id="legs-select"></select>
      </div>
      <div class="control-group">
        <label>Current Model:</label>
        <div
          id="model-indicator"
          style="
            font-size: 12px;
            color: #666;
            padding: 5px;
            background: #f0f0f0;
            border-radius: 4px;
          "
        >
          Loading...
        </div>
      </div>
    </div>

    <canvas id="c"></canvas>

    <!-- Import Three.js and necessary loaders -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <!-- No external QR library needed - using API service instead -->

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // ##### CONFIGURATION #####

      // 1. Available couch models with descriptions
      const MODEL_OPTIONS = [
        {
          name: "S77-1CL2SDR",
          path: "glb/S77-1CL2SDR.glb",
          description: "Classic 2-Seater with Wood Legs",
        },
        {
          name: "S77-2CL2D",
          path: "glb/S77-2CL2D.glb",
          description: "Premium 2-Seater with Wood Base",
        },
        {
          name: "S77-1F",
          path: "glb/S77-1F.glb",
          description: "Compact Single with Wood Frame",
        },
        {
          name: "S77-2SDL1CR",
          path: "glb/S77-2SDL1CR.glb",
          description: "Modern 2-Seater with Metal Legs",
        },
        {
          name: "S77-2D2CR",
          path: "glb/S77-2D2CR.glb",
          description: "Deluxe 2-Seater with Chrome Base",
        },
        {
          name: "S77-2SDL2CR1",
          path: "glb/S77-2SDL2CR1.glb",
          description: "Luxury 2-Seater with Metal Frame",
        },
        {
          name: "S77-2SDL2CR1CR",
          path: "glb/S77-2SDL2CR1CR.glb",
          description: "Executive 2-Seater with Chrome Details",
        },
        {
          name: "S77-12CL2SDR",
          path: "glb/S77-12CL2SDR.glb",
          description: "Large 3-Seater with Wood Legs",
        },
        {
          name: "S77-1CL2Ð¡L2SDR",
          path: "glb/S77-1CL2Ð¡L2SDR.glb",
          description: "Extended 2-Seater Configuration",
        },
        {
          name: "S77-1D2",
          path: "glb/S77-1D2.glb",
          description: "Minimalist Single Seater",
        },
        {
          name: "S77-21D",
          path: "glb/S77-21D.glb",
          description: "Compact 2-Seater Design",
        },
        {
          name: "S77-KT1",
          path: "glb/S77-KT1.glb",
          description: "Corner Table Accessory",
        },
        {
          name: "S77-P1",
          path: "glb/S77-P1.glb",
          description: "Ottoman/Footrest",
        },
      ];

      let currentModelPath = MODEL_OPTIONS[0].path;

      // Function to get the current selected model path
      function getCurrentModelPath() {
        const modelSelect = document.getElementById("model-select");
        if (modelSelect && modelSelect.value) {
          const selectedModel = MODEL_OPTIONS.find(
            (model) => model.name === modelSelect.value
          );
          return selectedModel ? selectedModel.path : MODEL_OPTIONS[0].path;
        }
        return currentModelPath;
      }

      // Function to update the model indicator
      function updateModelIndicator(modelPath) {
        const indicator = document.getElementById("model-indicator");
        if (indicator) {
          const modelName = modelPath.split("/").pop().replace(".glb", "");
          indicator.textContent = modelName;
          indicator.style.color = "#007acc";
        }
      }

      // 2. Universal component detection - automatically finds meshes by name patterns
      // These will be populated automatically when the model loads
      let bodyMeshes = []; // Meshes with "Body" in name
      let planeMeshes = []; // Meshes with "Plane" in name (follows body color)
      let stitchMeshes = []; // Meshes with "Stitch" in name (separate fabric option)
      let legsMeshes = []; // Meshes with "Legs" in name

      // 3. The repeating scale for all textures
      const TEXTURE_SCALE = 0.06;

      // 4. Define your available textures here. Add as many as you want!
      const FABRIC_OPTIONS = [
        {
          name: "Cloud",
          maps: {
            color:
              "textures/fabrics/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264_col.jpg",
            roughness:
              "textures/fabrics/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264_rough.jpg",
            normal:
              "textures/fabrics/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264_nrm.jpg",
            metalness:
              "textures/fabrics/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264_met.jpg",
          },
        },
        {
          name: "Limestone",
          maps: {
            color:
              "textures/fabrics/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74_col.jpg",
            roughness:
              "textures/fabrics/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74_rough.jpg",
            normal:
              "textures/fabrics/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74_nrm.jpg",
            metalness:
              "textures/fabrics/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74_met.jpg",
          },
        },
        {
          name: "Flax",
          maps: {
            color:
              "textures/fabrics/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c_col.jpg",
            roughness:
              "textures/fabrics/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c_rough.jpg",
            normal:
              "textures/fabrics/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c_nrm.jpg",
            metalness:
              "textures/fabrics/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c_met.jpg",
          },
        },
        {
          name: "Bonbon",
          maps: {
            color:
              "textures/fabrics/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6_col.jpg",
            roughness:
              "textures/fabrics/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6_rough.jpg",
            normal:
              "textures/fabrics/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6_nrm.jpg",
            metalness:
              "textures/fabrics/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6_met.jpg",
          },
        },
        {
          name: "Rough Sofa Fabric",
          maps: {
            color:
              "textures/fabrics/rough-sofa-fabric-bl/rough-sofa-fabric_albedo.png",
            roughness:
              "textures/fabrics/rough-sofa-fabric-bl/rough-sofa-fabric_roughness.png",
            normal:
              "textures/fabrics/rough-sofa-fabric-bl/rough-sofa-fabric_normal-ogl.png",
            metalness:
              "textures/fabrics/rough-sofa-fabric-bl/rough-sofa-fabric_metallic.png",
          },
        },
      ];

      const LEG_OPTIONS = [
        {
          name: "Rosewood Veneer",
          maps: {
            color:
              "textures/legs/rosewood_veneer1_4k.blend/rosewood_veneer1_diff_4k.jpg",
          },
        },
        {
          name: "Polished Metal",
          maps: {
            color: "textures/legs/PolishedMetal/color.jpg",
            roughness: "textures/legs/PolishedMetal/roughness.jpg",
            metalness: "textures/legs/PolishedMetal/metalness.jpg",
          },
        },
      ];

      // ##### SCRIPT - DO NOT EDIT BELOW #####

      const canvas = document.querySelector("#c");
      const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.setSize(window.innerWidth, window.innerHeight);

      // Enable shadows
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Basic tone mapping
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;

      const scene = new THREE.Scene();

      // Create a subtle gradient background for more depth
      const gradientTexture = new THREE.CanvasTexture(createGradientCanvas());
      scene.background = gradientTexture;

      // Add subtle fog for atmospheric depth
      scene.fog = new THREE.Fog(0xf8f8f8, 10, 50);

      // Function to create gradient background
      function createGradientCanvas() {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");

        const gradient = ctx.createLinearGradient(0, 0, 0, 512);
        gradient.addColorStop(0, "#ffffff");
        gradient.addColorStop(0.5, "#f8f8f8");
        gradient.addColorStop(1, "#e8e8e8");

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 512);

        return canvas;
      }

      const camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(3, 2, 3);

      const controls = new OrbitControls(camera, canvas);
      controls.target.set(0, 0.5, 0);

      // Balanced zoom controls - responsive but not overwhelming
      controls.enableZoom = true;
      controls.zoomSpeed = 1.2;
      controls.minDistance = 0.8;
      controls.maxDistance = 15;

      // Smooth rotation controls
      controls.enableRotate = true;
      controls.rotateSpeed = 0.8;
      controls.minPolarAngle = 0;
      controls.maxPolarAngle = Math.PI;

      // Smooth panning
      controls.enablePan = true;
      controls.panSpeed = 1.0;
      controls.screenSpacePanning = false;

      // Smooth damping for natural feel
      controls.enableDamping = true;
      controls.dampingFactor = 0.1;

      controls.update();

      // Professional 3-point lighting setup for furniture showcase

      // 1. Key Light - Main directional light from front-right with ultra-high quality shadows
      const keyLight = new THREE.DirectionalLight(0xffffff, 1.4);
      keyLight.position.set(5, 8, 4);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.width = 4096; // Ultra-high resolution shadows
      keyLight.shadow.mapSize.height = 4096;
      keyLight.shadow.camera.near = 0.1;
      keyLight.shadow.camera.far = 100;
      keyLight.shadow.camera.left = -15;
      keyLight.shadow.camera.right = 15;
      keyLight.shadow.camera.top = 15;
      keyLight.shadow.camera.bottom = -15;
      keyLight.shadow.radius = 8; // Soft shadow edges
      keyLight.shadow.blurSamples = 25; // High quality blur
      scene.add(keyLight);

      // 2. Fill Light - Softer light from front-left with subtle shadows
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.7);
      fillLight.position.set(-4, 5, 3);
      fillLight.castShadow = true;
      fillLight.shadow.mapSize.width = 2048;
      fillLight.shadow.mapSize.height = 2048;
      fillLight.shadow.camera.near = 0.1;
      fillLight.shadow.camera.far = 50;
      fillLight.shadow.camera.left = -10;
      fillLight.shadow.camera.right = 10;
      fillLight.shadow.camera.top = 10;
      fillLight.shadow.camera.bottom = -10;
      fillLight.shadow.radius = 4;
      scene.add(fillLight);

      // 3. Rim Light - Back light to create dramatic edge definition
      const rimLight = new THREE.DirectionalLight(0xffffff, 1.0);
      rimLight.position.set(-3, 4, -6);
      rimLight.castShadow = true;
      rimLight.shadow.mapSize.width = 2048;
      rimLight.shadow.mapSize.height = 2048;
      rimLight.shadow.camera.near = 0.1;
      rimLight.shadow.camera.far = 50;
      rimLight.shadow.radius = 6;
      scene.add(rimLight);

      // 4. Ambient Light - Soft overall illumination
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      // 5. Environment Light - Hemisphere light for natural feel
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
      hemiLight.position.set(0, 20, 0);
      scene.add(hemiLight);

      // 6. Accent Lights - Dramatic spotlights for material highlights
      const spotLight1 = new THREE.SpotLight(0xffffff, 0.8);
      spotLight1.position.set(3, 6, 5);
      spotLight1.angle = Math.PI / 5;
      spotLight1.penumbra = 0.4;
      spotLight1.decay = 1.5;
      spotLight1.distance = 25;
      spotLight1.castShadow = true;
      spotLight1.shadow.mapSize.width = 1024;
      spotLight1.shadow.mapSize.height = 1024;
      spotLight1.shadow.radius = 10;
      scene.add(spotLight1);

      const spotLight2 = new THREE.SpotLight(0xffffff, 0.6);
      spotLight2.position.set(-3, 4, 5);
      spotLight2.angle = Math.PI / 6;
      spotLight2.penumbra = 0.5;
      spotLight2.decay = 1.8;
      spotLight2.distance = 20;
      spotLight2.castShadow = true;
      spotLight2.shadow.mapSize.width = 1024;
      spotLight2.shadow.mapSize.height = 1024;
      spotLight2.shadow.radius = 8;
      scene.add(spotLight2);

      // 7. Additional dramatic accent light from above
      const topSpotLight = new THREE.SpotLight(0xffffff, 0.4);
      topSpotLight.position.set(0, 8, 0);
      topSpotLight.angle = Math.PI / 4;
      topSpotLight.penumbra = 0.6;
      topSpotLight.decay = 2;
      topSpotLight.distance = 30;
      topSpotLight.castShadow = true;
      topSpotLight.shadow.mapSize.width = 2048;
      topSpotLight.shadow.mapSize.height = 2048;
      topSpotLight.shadow.radius = 12;
      scene.add(topSpotLight);

      // Add an enhanced ground plane with subtle reflective properties
      const groundGeometry = new THREE.PlaneGeometry(30, 30);
      const groundMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xfafafa,
        transparent: true,
        opacity: 0.15,
        roughness: 0.8,
        metalness: 0.1,
        reflectivity: 0.2,
        clearcoat: 0.1,
        clearcoatRoughness: 0.9,
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.05;
      ground.receiveShadow = true;
      scene.add(ground);

      // Add a secondary shadow catcher plane for deeper shadows
      const shadowCatcherGeometry = new THREE.PlaneGeometry(25, 25);
      const shadowCatcherMaterial = new THREE.ShadowMaterial({
        opacity: 0.3,
        transparent: true,
      });
      const shadowCatcher = new THREE.Mesh(
        shadowCatcherGeometry,
        shadowCatcherMaterial
      );
      shadowCatcher.rotation.x = -Math.PI / 2;
      shadowCatcher.position.y = -0.02;
      shadowCatcher.receiveShadow = true;
      scene.add(shadowCatcher);

      const textureLoader = new THREE.TextureLoader();

      function createPbrMaterial(mapPaths) {
        const material = new THREE.MeshStandardMaterial();
        const applyTexture = (mapType, path) => {
          const texture = textureLoader.load(path);
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(TEXTURE_SCALE, TEXTURE_SCALE);
          texture.flipY = false;
          if (mapType === "color") {
            texture.colorSpace = THREE.SRGBColorSpace;
            material.map = texture;
          } else if (mapType === "roughness") {
            material.roughnessMap = texture;
          } else if (mapType === "normal") {
            material.normalMap = texture;
          } else if (mapType === "metalness") {
            material.metalnessMap = texture;
          }
        };
        if (mapPaths.color) applyTexture("color", mapPaths.color);
        if (mapPaths.roughness) applyTexture("roughness", mapPaths.roughness);
        if (mapPaths.normal) applyTexture("normal", mapPaths.normal);
        if (mapPaths.metalness) applyTexture("metalness", mapPaths.metalness);
        return material;
      }

      // <<< NEW CODE HERE (1/2) >>>
      // This function calculates the model's size and moves the camera to frame it perfectly.
      function frameObject(objectToFrame) {
        const box = new THREE.Box3().setFromObject(objectToFrame);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());

        const maxSize = Math.max(size.x, size.y, size.z);
        const fitHeightDistance =
          maxSize / (2 * Math.tan((camera.fov * Math.PI) / 360));
        const fitWidthDistance = fitHeightDistance / camera.aspect;
        const distance = 1.5 * Math.max(fitHeightDistance, fitWidthDistance); // add 50% padding

        const direction = controls.target
          .clone()
          .sub(camera.position)
          .normalize()
          .multiplyScalar(distance);

        camera.position.copy(center).sub(direction);
        controls.target.copy(center);
        controls.update();
      }

      const gltfLoader = new GLTFLoader();
      let currentModel = null;

      function loadModel(modelPath) {
        console.log("ðŸ”„ Loading model:", modelPath);

        // Show loading state
        const indicator = document.getElementById("model-indicator");
        if (indicator) {
          indicator.textContent = "Loading model...";
          indicator.style.color = "#ff9500";
        }

        // Remove existing model if any
        if (currentModel) {
          scene.remove(currentModel);
          currentModel = null;
          // Clear mesh arrays
          bodyMeshes.length = 0;
          planeMeshes.length = 0;
          stitchMeshes.length = 0;
          legsMeshes.length = 0;
        }

        gltfLoader.load(
          modelPath,
          (gltf) => {
            console.log("Model loaded successfully:", modelPath);
            const model = gltf.scene;
            currentModel = model;

            // Universal component detection - automatically categorize meshes by name patterns
            model.traverse((child) => {
              if (child.isMesh) {
                // Enable shadows for all meshes
                child.castShadow = true;
                child.receiveShadow = true;

                const meshName = child.name.toLowerCase();

                if (meshName.includes("body")) {
                  bodyMeshes.push(child);
                  console.log(`Found body mesh: ${child.name}`);
                } else if (meshName.includes("plane")) {
                  planeMeshes.push(child);
                  console.log(`Found plane mesh: ${child.name}`);
                } else if (meshName.includes("stitch")) {
                  stitchMeshes.push(child);
                  console.log(`Found stitch mesh: ${child.name}`);
                } else if (meshName.includes("legs")) {
                  legsMeshes.push(child);
                  console.log(`Found legs mesh: ${child.name}`);
                }
              }
            });

            console.log(`Component detection complete:
          - Body meshes: ${bodyMeshes.length}
          - Plane meshes: ${planeMeshes.length}
          - Stitch meshes: ${stitchMeshes.length}
          - Legs meshes: ${legsMeshes.length}`);

            scene.add(model);
            console.log("âœ… Model added to scene");

            // Update model indicator
            const indicator = document.getElementById("model-indicator");
            if (indicator) {
              const modelName = modelPath.split("/").pop().replace(".glb", "");
              indicator.textContent = modelName;
              indicator.style.color = "#28a745";
            }

            updateMaterials();
            frameObject(model);
          },
          (progress) => {
            console.log(
              "Loading progress:",
              (progress.loaded / progress.total) * 100 + "%"
            );
          },
          (error) => {
            console.error("Error loading model:", error);
            console.error("Model path:", modelPath);
          }
        );
      }

      // Load initial model
      loadModel(currentModelPath);

      const modelSelect = document.getElementById("model-select");
      const fabricSelect = document.getElementById("fabric-select");
      const stitchSelect = document.getElementById("stitch-select");
      const legsSelect = document.getElementById("legs-select");

      // Populate model options
      MODEL_OPTIONS.forEach((model) => {
        const option = document.createElement("option");
        option.value = model.name;
        option.textContent = `${model.name} - ${model.description}`;
        modelSelect.appendChild(option);
      });

      // Populate fabric options for body/plane
      FABRIC_OPTIONS.forEach((opt) => {
        const option = document.createElement("option");
        option.value = opt.name;
        option.textContent = opt.name;
        fabricSelect.appendChild(option);
      });

      // Populate stitch color options (same as fabric options)
      FABRIC_OPTIONS.forEach((opt) => {
        const option = document.createElement("option");
        option.value = opt.name;
        option.textContent = opt.name;
        stitchSelect.appendChild(option);
      });

      // Populate leg options
      LEG_OPTIONS.forEach((opt) => {
        const option = document.createElement("option");
        option.value = opt.name;
        option.textContent = opt.name;
        legsSelect.appendChild(option);
      });

      function updateMaterials() {
        const selectedFabricName = fabricSelect.value;
        const selectedStitchName = stitchSelect.value;
        const selectedLegsName = legsSelect.value;

        // Model is now selected manually, just apply materials to current model
        console.log(
          "âœ… Applying materials to current model:",
          currentModelPath
        );
        console.log("ðŸ“‹ Configuration:", {
          fabric: selectedFabricName,
          stitch: selectedStitchName,
          legs: selectedLegsName,
        });

        // Apply materials to current model (if textures need adjustment)
        const fabricData = FABRIC_OPTIONS.find(
          (opt) => opt.name === selectedFabricName
        );
        const stitchData = FABRIC_OPTIONS.find(
          (opt) => opt.name === selectedStitchName
        );
        const legsData = LEG_OPTIONS.find(
          (opt) => opt.name === selectedLegsName
        );

        // Apply fabric material to body meshes
        if (fabricData && bodyMeshes.length > 0) {
          const bodyMaterial = createPbrMaterial(fabricData.maps);
          bodyMeshes.forEach((mesh) => (mesh.material = bodyMaterial));

          // Plane meshes follow the same color as body
          planeMeshes.forEach((mesh) => (mesh.material = bodyMaterial));
        }

        // Apply stitch material (separate fabric choice)
        if (stitchData && stitchMeshes.length > 0) {
          const stitchMaterial = createPbrMaterial(stitchData.maps);
          stitchMeshes.forEach((mesh) => (mesh.material = stitchMaterial));
        }

        // Apply legs material
        if (legsData && legsMeshes.length > 0) {
          const legsMaterial = createPbrMaterial(legsData.maps);
          legsMeshes.forEach((mesh) => (mesh.material = legsMaterial));
        }
      }

      modelSelect.addEventListener("change", () => {
        const newModelPath = getCurrentModelPath();
        if (newModelPath !== currentModelPath) {
          currentModelPath = newModelPath;
          console.log("ðŸ”„ User selected different model:", currentModelPath);
          loadModel(currentModelPath);
        }
      });

      fabricSelect.addEventListener("change", () => {
        updateMaterials();
      });
      stitchSelect.addEventListener("change", () => {
        updateMaterials();
      });
      legsSelect.addEventListener("change", () => {
        updateMaterials();
      });

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }
      function animate() {
        if (resizeRendererToDisplaySize(renderer)) {
          const canvas = renderer.domElement;
          camera.aspect = canvas.clientWidth / canvas.clientHeight;
          camera.updateProjectionMatrix();
        }

        // Update controls for smooth damping
        controls.update();

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      // Start the animation loop
      console.log("Starting animation loop");
      requestAnimationFrame(animate);

      // Debug: Log scene contents after a short delay
      setTimeout(() => {
        console.log("Scene children count:", scene.children.length);
        console.log("Camera position:", camera.position);
        console.log("Controls target:", controls.target);
      }, 2000);
    </script>
  </body>
</html>
