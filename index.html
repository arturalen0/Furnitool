<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Couch Configurator</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: sans-serif;
      }

      canvas {
        display: block;
        width: 100vw !important;
        height: 100vh !important;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 1;
      }
      #ui-container {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(255, 255, 255, 0.9);
        padding: 15px;
        border-radius: 10px;
        z-index: 10;
        backdrop-filter: blur(5px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      #qr-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.95);
        padding: 15px;
        border-radius: 10px;
        z-index: 10;
        backdrop-filter: blur(5px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        text-align: center;
        max-width: 200px;
      }

      #qr-code {
        width: 150px;
        height: 150px;
        margin: 10px 0;
      }

      #qr-container h4 {
        margin: 0 0 10px 0;
        font-size: 14px;
        color: #333;
      }

      #qr-container p {
        margin: 10px 0 0 0;
        font-size: 12px;
        color: #666;
        line-height: 1.4;
      }
      .control-group {
        margin-bottom: 10px;
      }
      label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      select {
        padding: 5px;
        border-radius: 5px;
        border: 1px solid #ccc;
      }
    </style>
  </head>
  <body>
    <div id="ui-container">
      <div class="control-group">
        <label for="fabric-select">Fabric Material:</label>
        <select id="fabric-select"></select>
      </div>
      <div class="control-group">
        <label for="stitch-select">Stitch Color:</label>
        <select id="stitch-select"></select>
      </div>
      <div class="control-group">
        <label for="legs-select">Legs Material:</label>
        <select id="legs-select"></select>
      </div>
    </div>

    <div id="qr-container">
      <h4>View in AR</h4>
      <div id="qr-code"></div>
      <p>Scan with your phone to see this couch in AR</p>
      <button
        onclick="updateQRCode()"
        style="
          margin-top: 10px;
          padding: 5px 10px;
          background: #007acc;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 12px;
        "
      >
        Regenerate QR
      </button>
    </div>
    <canvas id="c"></canvas>

    <!-- Import Three.js and necessary loaders -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <!-- No external QR library needed - using API service instead -->

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // ##### CONFIGURATION #####

      // 1. Path to your main GLB model
      const MODEL_PATH = "couch.glb";

      // 2. Universal component detection - automatically finds meshes by name patterns
      // These will be populated automatically when the model loads
      let bodyMeshes = []; // Meshes with "Body" in name
      let planeMeshes = []; // Meshes with "Plane" in name (follows body color)
      let stitchMeshes = []; // Meshes with "Stitch" in name (separate fabric option)
      let legsMeshes = []; // Meshes with "Legs" in name

      // 3. The repeating scale for all textures
      const TEXTURE_SCALE = 0.06;

      // 4. Define your available textures here. Add as many as you want!
      const FABRIC_OPTIONS = [
        {
          name: "Cloud",
          maps: {
            color:
              "textures/fabrics/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264_col.jpg",
            roughness:
              "textures/fabrics/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264_rough.jpg",
            normal:
              "textures/fabrics/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264_nrm.jpg",
            metalness:
              "textures/fabrics/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264/twinbru_Sabato_28-Cloud_78bc31df720040f98507df3a952a4264_met.jpg",
          },
        },
        {
          name: "Limestone",
          maps: {
            color:
              "textures/fabrics/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74_col.jpg",
            roughness:
              "textures/fabrics/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74_rough.jpg",
            normal:
              "textures/fabrics/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74_nrm.jpg",
            metalness:
              "textures/fabrics/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74/twinbru_Sabato_01-Limestone_dcdf6528525142e98efbccff9cd72c74_met.jpg",
          },
        },
        {
          name: "Flax",
          maps: {
            color:
              "textures/fabrics/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c_col.jpg",
            roughness:
              "textures/fabrics/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c_rough.jpg",
            normal:
              "textures/fabrics/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c_nrm.jpg",
            metalness:
              "textures/fabrics/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c/twinbru_Sabato_06-Flax_7932749150ae466099eb91ff8fc2909c_met.jpg",
          },
        },
        {
          name: "Bonbon",
          maps: {
            color:
              "textures/fabrics/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6_col.jpg",
            roughness:
              "textures/fabrics/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6_rough.jpg",
            normal:
              "textures/fabrics/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6_nrm.jpg",
            metalness:
              "textures/fabrics/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6/twinbru_Sabato_17-Bonbon_5f4a348fcb2444bb91a9fcb93c3de7c6_met.jpg",
          },
        },
        {
          name: "Rough Sofa Fabric",
          maps: {
            color:
              "textures/fabrics/rough-sofa-fabric-bl/rough-sofa-fabric_albedo.png",
            roughness:
              "textures/fabrics/rough-sofa-fabric-bl/rough-sofa-fabric_roughness.png",
            normal:
              "textures/fabrics/rough-sofa-fabric-bl/rough-sofa-fabric_normal-ogl.png",
            metalness:
              "textures/fabrics/rough-sofa-fabric-bl/rough-sofa-fabric_metallic.png",
          },
        },
      ];

      const LEG_OPTIONS = [
        {
          name: "Rosewood Veneer",
          maps: {
            color:
              "textures/legs/rosewood_veneer1_4k.blend/rosewood_veneer1_diff_4k.jpg",
          },
        },
        {
          name: "Polished Metal",
          maps: {
            color: "textures/legs/PolishedMetal/color.jpg",
            roughness: "textures/legs/PolishedMetal/roughness.jpg",
            metalness: "textures/legs/PolishedMetal/metalness.jpg",
          },
        },
      ];

      // ##### SCRIPT - DO NOT EDIT BELOW #####

      const canvas = document.querySelector("#c");
      const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.setSize(window.innerWidth, window.innerHeight);

      // Enable shadows
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Basic tone mapping
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;

      const scene = new THREE.Scene();

      // Create a subtle gradient background for more depth
      const gradientTexture = new THREE.CanvasTexture(createGradientCanvas());
      scene.background = gradientTexture;

      // Add subtle fog for atmospheric depth
      scene.fog = new THREE.Fog(0xf8f8f8, 10, 50);

      // Function to create gradient background
      function createGradientCanvas() {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");

        const gradient = ctx.createLinearGradient(0, 0, 0, 512);
        gradient.addColorStop(0, "#ffffff");
        gradient.addColorStop(0.5, "#f8f8f8");
        gradient.addColorStop(1, "#e8e8e8");

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 512);

        return canvas;
      }

      const camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(3, 2, 3);

      const controls = new OrbitControls(camera, canvas);
      controls.target.set(0, 0.5, 0);

      // Balanced zoom controls - responsive but not overwhelming
      controls.enableZoom = true;
      controls.zoomSpeed = 1.2;
      controls.minDistance = 0.8;
      controls.maxDistance = 15;

      // Smooth rotation controls
      controls.enableRotate = true;
      controls.rotateSpeed = 0.8;
      controls.minPolarAngle = 0;
      controls.maxPolarAngle = Math.PI;

      // Smooth panning
      controls.enablePan = true;
      controls.panSpeed = 1.0;
      controls.screenSpacePanning = false;

      // Smooth damping for natural feel
      controls.enableDamping = true;
      controls.dampingFactor = 0.1;

      controls.update();

      // Professional 3-point lighting setup for furniture showcase

      // 1. Key Light - Main directional light from front-right with ultra-high quality shadows
      const keyLight = new THREE.DirectionalLight(0xffffff, 1.4);
      keyLight.position.set(5, 8, 4);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.width = 4096; // Ultra-high resolution shadows
      keyLight.shadow.mapSize.height = 4096;
      keyLight.shadow.camera.near = 0.1;
      keyLight.shadow.camera.far = 100;
      keyLight.shadow.camera.left = -15;
      keyLight.shadow.camera.right = 15;
      keyLight.shadow.camera.top = 15;
      keyLight.shadow.camera.bottom = -15;
      keyLight.shadow.radius = 8; // Soft shadow edges
      keyLight.shadow.blurSamples = 25; // High quality blur
      scene.add(keyLight);

      // 2. Fill Light - Softer light from front-left with subtle shadows
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.7);
      fillLight.position.set(-4, 5, 3);
      fillLight.castShadow = true;
      fillLight.shadow.mapSize.width = 2048;
      fillLight.shadow.mapSize.height = 2048;
      fillLight.shadow.camera.near = 0.1;
      fillLight.shadow.camera.far = 50;
      fillLight.shadow.camera.left = -10;
      fillLight.shadow.camera.right = 10;
      fillLight.shadow.camera.top = 10;
      fillLight.shadow.camera.bottom = -10;
      fillLight.shadow.radius = 4;
      scene.add(fillLight);

      // 3. Rim Light - Back light to create dramatic edge definition
      const rimLight = new THREE.DirectionalLight(0xffffff, 1.0);
      rimLight.position.set(-3, 4, -6);
      rimLight.castShadow = true;
      rimLight.shadow.mapSize.width = 2048;
      rimLight.shadow.mapSize.height = 2048;
      rimLight.shadow.camera.near = 0.1;
      rimLight.shadow.camera.far = 50;
      rimLight.shadow.radius = 6;
      scene.add(rimLight);

      // 4. Ambient Light - Soft overall illumination
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      // 5. Environment Light - Hemisphere light for natural feel
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
      hemiLight.position.set(0, 20, 0);
      scene.add(hemiLight);

      // 6. Accent Lights - Dramatic spotlights for material highlights
      const spotLight1 = new THREE.SpotLight(0xffffff, 0.8);
      spotLight1.position.set(3, 6, 5);
      spotLight1.angle = Math.PI / 5;
      spotLight1.penumbra = 0.4;
      spotLight1.decay = 1.5;
      spotLight1.distance = 25;
      spotLight1.castShadow = true;
      spotLight1.shadow.mapSize.width = 1024;
      spotLight1.shadow.mapSize.height = 1024;
      spotLight1.shadow.radius = 10;
      scene.add(spotLight1);

      const spotLight2 = new THREE.SpotLight(0xffffff, 0.6);
      spotLight2.position.set(-3, 4, 5);
      spotLight2.angle = Math.PI / 6;
      spotLight2.penumbra = 0.5;
      spotLight2.decay = 1.8;
      spotLight2.distance = 20;
      spotLight2.castShadow = true;
      spotLight2.shadow.mapSize.width = 1024;
      spotLight2.shadow.mapSize.height = 1024;
      spotLight2.shadow.radius = 8;
      scene.add(spotLight2);

      // 7. Additional dramatic accent light from above
      const topSpotLight = new THREE.SpotLight(0xffffff, 0.4);
      topSpotLight.position.set(0, 8, 0);
      topSpotLight.angle = Math.PI / 4;
      topSpotLight.penumbra = 0.6;
      topSpotLight.decay = 2;
      topSpotLight.distance = 30;
      topSpotLight.castShadow = true;
      topSpotLight.shadow.mapSize.width = 2048;
      topSpotLight.shadow.mapSize.height = 2048;
      topSpotLight.shadow.radius = 12;
      scene.add(topSpotLight);

      // Add an enhanced ground plane with subtle reflective properties
      const groundGeometry = new THREE.PlaneGeometry(30, 30);
      const groundMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xfafafa,
        transparent: true,
        opacity: 0.15,
        roughness: 0.8,
        metalness: 0.1,
        reflectivity: 0.2,
        clearcoat: 0.1,
        clearcoatRoughness: 0.9,
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.05;
      ground.receiveShadow = true;
      scene.add(ground);

      // Add a secondary shadow catcher plane for deeper shadows
      const shadowCatcherGeometry = new THREE.PlaneGeometry(25, 25);
      const shadowCatcherMaterial = new THREE.ShadowMaterial({
        opacity: 0.3,
        transparent: true,
      });
      const shadowCatcher = new THREE.Mesh(
        shadowCatcherGeometry,
        shadowCatcherMaterial
      );
      shadowCatcher.rotation.x = -Math.PI / 2;
      shadowCatcher.position.y = -0.02;
      shadowCatcher.receiveShadow = true;
      scene.add(shadowCatcher);

      const textureLoader = new THREE.TextureLoader();

      function createPbrMaterial(mapPaths) {
        const material = new THREE.MeshStandardMaterial();
        const applyTexture = (mapType, path) => {
          const texture = textureLoader.load(path);
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(TEXTURE_SCALE, TEXTURE_SCALE);
          texture.flipY = false;
          if (mapType === "color") {
            texture.colorSpace = THREE.SRGBColorSpace;
            material.map = texture;
          } else if (mapType === "roughness") {
            material.roughnessMap = texture;
          } else if (mapType === "normal") {
            material.normalMap = texture;
          } else if (mapType === "metalness") {
            material.metalnessMap = texture;
          }
        };
        if (mapPaths.color) applyTexture("color", mapPaths.color);
        if (mapPaths.roughness) applyTexture("roughness", mapPaths.roughness);
        if (mapPaths.normal) applyTexture("normal", mapPaths.normal);
        if (mapPaths.metalness) applyTexture("metalness", mapPaths.metalness);
        return material;
      }

      // <<< NEW CODE HERE (1/2) >>>
      // This function calculates the model's size and moves the camera to frame it perfectly.
      function frameObject(objectToFrame) {
        const box = new THREE.Box3().setFromObject(objectToFrame);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());

        const maxSize = Math.max(size.x, size.y, size.z);
        const fitHeightDistance =
          maxSize / (2 * Math.tan((camera.fov * Math.PI) / 360));
        const fitWidthDistance = fitHeightDistance / camera.aspect;
        const distance = 1.5 * Math.max(fitHeightDistance, fitWidthDistance); // add 50% padding

        const direction = controls.target
          .clone()
          .sub(camera.position)
          .normalize()
          .multiplyScalar(distance);

        camera.position.copy(center).sub(direction);
        controls.target.copy(center);
        controls.update();
      }

      const gltfLoader = new GLTFLoader();
      gltfLoader.load(
        MODEL_PATH,
        (gltf) => {
          console.log("Model loaded successfully:", MODEL_PATH);
          const model = gltf.scene;

          // Universal component detection - automatically categorize meshes by name patterns
          model.traverse((child) => {
            if (child.isMesh) {
              // Enable shadows for all meshes
              child.castShadow = true;
              child.receiveShadow = true;

              const meshName = child.name.toLowerCase();

              if (meshName.includes("body")) {
                bodyMeshes.push(child);
                console.log(`Found body mesh: ${child.name}`);
              } else if (meshName.includes("plane")) {
                planeMeshes.push(child);
                console.log(`Found plane mesh: ${child.name}`);
              } else if (meshName.includes("stitch")) {
                stitchMeshes.push(child);
                console.log(`Found stitch mesh: ${child.name}`);
              } else if (meshName.includes("legs")) {
                legsMeshes.push(child);
                console.log(`Found legs mesh: ${child.name}`);
              }
            }
          });

          console.log(`Component detection complete:
          - Body meshes: ${bodyMeshes.length}
          - Plane meshes: ${planeMeshes.length}
          - Stitch meshes: ${stitchMeshes.length}
          - Legs meshes: ${legsMeshes.length}`);

          scene.add(model);
          console.log("Model added to scene");
          updateMaterials();
          frameObject(model);
        },
        (progress) => {
          console.log(
            "Loading progress:",
            (progress.loaded / progress.total) * 100 + "%"
          );
        },
        (error) => {
          console.error("Error loading model:", error);
          console.error("Model path:", MODEL_PATH);
        }
      );

      const fabricSelect = document.getElementById("fabric-select");
      const stitchSelect = document.getElementById("stitch-select");
      const legsSelect = document.getElementById("legs-select");

      // Populate fabric options for body/plane
      FABRIC_OPTIONS.forEach((opt) => {
        const option = document.createElement("option");
        option.value = opt.name;
        option.textContent = opt.name;
        fabricSelect.appendChild(option);
      });

      // Populate stitch color options (same as fabric options)
      FABRIC_OPTIONS.forEach((opt) => {
        const option = document.createElement("option");
        option.value = opt.name;
        option.textContent = opt.name;
        stitchSelect.appendChild(option);
      });

      // Populate leg options
      LEG_OPTIONS.forEach((opt) => {
        const option = document.createElement("option");
        option.value = opt.name;
        option.textContent = opt.name;
        legsSelect.appendChild(option);
      });

      function updateMaterials() {
        const selectedFabricName = fabricSelect.value;
        const selectedStitchName = stitchSelect.value;
        const selectedLegsName = legsSelect.value;

        // Get material data
        const fabricData = FABRIC_OPTIONS.find(
          (opt) => opt.name === selectedFabricName
        );
        const stitchData = FABRIC_OPTIONS.find(
          (opt) => opt.name === selectedStitchName
        );
        const legsData = LEG_OPTIONS.find(
          (opt) => opt.name === selectedLegsName
        );

        // Apply fabric material to body meshes
        if (fabricData) {
          const bodyMaterial = createPbrMaterial(fabricData.maps);
          bodyMeshes.forEach((mesh) => (mesh.material = bodyMaterial));

          // Plane meshes follow the same color as body
          planeMeshes.forEach((mesh) => (mesh.material = bodyMaterial));
        }

        // Apply stitch material (separate fabric choice)
        if (stitchData) {
          const stitchMaterial = createPbrMaterial(stitchData.maps);
          stitchMeshes.forEach((mesh) => (mesh.material = stitchMaterial));
        }

        // Apply legs material
        if (legsData) {
          const legsMaterial = createPbrMaterial(legsData.maps);
          legsMeshes.forEach((mesh) => (mesh.material = legsMaterial));
        }
      }

      fabricSelect.addEventListener("change", () => {
        updateMaterials();
        updateQRCode();
      });
      stitchSelect.addEventListener("change", () => {
        updateMaterials();
        updateQRCode();
      });
      legsSelect.addEventListener("change", () => {
        updateMaterials();
        updateQRCode();
      });

      // Generate initial QR code with delay to ensure DOM is ready
      setTimeout(() => {
        console.log("Attempting to generate initial QR code...");
        updateQRCode();
      }, 1000);

      function updateQRCode() {
        console.log("updateQRCode function called");

        const qrContainer = document.getElementById("qr-code");
        console.log("QR container found:", !!qrContainer);

        if (!qrContainer) {
          console.error("QR container not found");
          return;
        }

        // First, let's just show a test message to confirm the container works
        qrContainer.innerHTML = `
          <div style="width: 150px; height: 150px; background: #e6f3ff; display: flex; flex-direction: column; align-items: center; justify-content: center; border: 2px solid #007acc; text-align: center; font-size: 12px; color: #007acc; padding: 10px; box-sizing: border-box; border-radius: 8px;">
            <div style="margin-bottom: 8px;">🔄 QR Test</div>
            <div style="font-size: 10px;">Function Working!</div>
          </div>
        `;

        const currentConfig = {
          fabric: fabricSelect.value || "Cloud",
          stitch: stitchSelect.value || "Cloud",
          legs: legsSelect.value || "Rosewood Veneer",
        };

        console.log("Current config:", currentConfig);

        // Create URL with configuration parameters
        const baseUrl =
          window.location.origin +
          window.location.pathname.replace("index.html", "");
        const arUrl = `${baseUrl}ar-viewer.html?fabric=${encodeURIComponent(
          currentConfig.fabric
        )}&stitch=${encodeURIComponent(
          currentConfig.stitch
        )}&legs=${encodeURIComponent(currentConfig.legs)}`;

        console.log("AR URL:", arUrl);

        // Try a simple QR API first
        const qrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(
          arUrl
        )}`;
        console.log("QR API URL:", qrApiUrl);

        // Show loading state
        setTimeout(() => {
          qrContainer.innerHTML = `
            <div style="width: 150px; height: 150px; display: flex; align-items: center; justify-content: center; font-size: 12px; color: #666; background: #f9f9f9; border-radius: 8px; border: 1px solid #ddd;">
              Loading QR...
            </div>
          `;

          // Create QR code image
          const qrImg = new Image();
          qrImg.crossOrigin = "anonymous"; // Try to avoid CORS issues

          qrImg.onload = function () {
            console.log("QR Code image loaded successfully!");
            qrContainer.innerHTML = "";
            qrImg.style.width = "150px";
            qrImg.style.height = "150px";
            qrImg.style.borderRadius = "8px";
            qrImg.style.boxShadow = "0 2px 8px rgba(0,0,0,0.1)";
            qrImg.style.border = "1px solid #ddd";
            qrContainer.appendChild(qrImg);
          };

          qrImg.onerror = function (e) {
            console.error("QR Code image failed to load:", e);
            qrContainer.innerHTML = `
              <div style="width: 150px; height: 150px; background: #ffe6e6; display: flex; flex-direction: column; align-items: center; justify-content: center; border: 2px solid #ff9999; text-align: center; font-size: 11px; color: #cc0000; padding: 10px; box-sizing: border-box; border-radius: 8px;">
                <div style="margin-bottom: 8px;">❌ QR Failed</div>
                <a href="${arUrl}" target="_blank" style="color: #007acc; text-decoration: none; font-size: 10px; padding: 4px 8px; background: #e6f3ff; border-radius: 4px;">Open AR Link</a>
              </div>
            `;
          };

          console.log("Setting image source...");
          qrImg.src = qrApiUrl;
        }, 500);
      }

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }
      function animate() {
        if (resizeRendererToDisplaySize(renderer)) {
          const canvas = renderer.domElement;
          camera.aspect = canvas.clientWidth / canvas.clientHeight;
          camera.updateProjectionMatrix();
        }

        // Update controls for smooth damping
        controls.update();

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      // Start the animation loop
      console.log("Starting animation loop");
      requestAnimationFrame(animate);

      // Debug: Log scene contents after a short delay
      setTimeout(() => {
        console.log("Scene children count:", scene.children.length);
        console.log("Camera position:", camera.position);
        console.log("Controls target:", controls.target);
      }, 2000);
    </script>
  </body>
</html>
